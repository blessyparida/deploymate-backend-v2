// src/app/api/github/utils/githubactions.ts
import { getAppOctokit } from "./githubAuth";

interface GithubActionsParams {
  owner: string;
  repo: string;
  branch: string; // base branch (main/master)
  installationId: number;
  generatedFiles?: Record<string, any>;
}

interface GithubActionResult {
  success: boolean;
  message: string;
  prUrl?: string;
  simulated?: boolean;
}

export async function generateGithubActions(
  params: GithubActionsParams
): Promise<GithubActionResult[]> {
  const { owner, repo, branch, installationId, generatedFiles = {} } = params;
  const octokit = await getAppOctokit({ owner, repo, installationId });

  const deploymentBranch = "deploymate-actions";

  try {
    //ensuring deployment branch exists
    let branchExists = true;

    try {
      await octokit.git.getRef({
        owner,
        repo,
        ref: `heads/${deploymentBranch}`,
      });
    } catch {
      branchExists = false;
    }

    if (!branchExists) {
      const { data: baseRef } = await octokit.git.getRef({
        owner,
        repo,
        ref: `heads/${branch}`,
      });

      await octokit.git.createRef({
        owner,
        repo,
        ref: `refs/heads/${deploymentBranch}`,
        sha: baseRef.object.sha,
      });
    }

   
     //commiting files
    for (const [filePath, rawContent] of Object.entries(generatedFiles)) {
      const content =
        typeof rawContent === "string"
          ? rawContent
          : JSON.stringify(rawContent, null, 2);

      let sha: string | undefined;

      
      try {
        const existing = await octokit.repos.getContent({
          owner,
          repo,
          path: filePath,
          ref: deploymentBranch,
        });

        if (!Array.isArray(existing.data)) {
          sha = existing.data.sha;
        }
      } catch {
        
        sha = undefined;
      }

      try {
        await octokit.repos.createOrUpdateFileContents({
          owner,
          repo,
          path: filePath,
          message: `chore: add/update ${filePath} via DeployMate`,
          content: Buffer.from(content).toString("base64"),
          branch: deploymentBranch,
          sha,
        });
      } catch (err: any) {
        
        if (err.status === 409) {
          const latest = await octokit.repos.getContent({
            owner,
            repo,
            path: filePath,
            ref: deploymentBranch,
          });

          if (!Array.isArray(latest.data)) {
            await octokit.repos.createOrUpdateFileContents({
              owner,
              repo,
              path: filePath,
              message: `chore: add/update ${filePath} via DeployMate`,
              content: Buffer.from(content).toString("base64"),
              branch: deploymentBranch,
              sha: latest.data.sha,
            });
          }
        } else {
          throw err;
        }
      }
    }

    
    const existingPRs = await octokit.pulls.list({
      owner,
      repo,
      head: `${owner}:${deploymentBranch}`,
      base: branch,
      state: "open",
    });

    if (existingPRs.data.length > 0) {
      return [
        {
          success: true,
          message: "Existing pull request already open",
          prUrl: existingPRs.data[0].html_url,
        },
      ];
    }

    
    const { data: pr } = await octokit.pulls.create({
      owner,
      repo,
      title: "Add deployment workflows via DeployMate",
      body: "Automated PR generated by DeployMate.",
      head: deploymentBranch,
      base: branch,
    });

    return [
      {
        success: true,
        message: "Pull request created successfully",
        prUrl: pr.html_url,
      },
    ];
  } catch (err: any) {
    console.error("generateGithubActions error:", err);
    return [
      {
        success: false,
        message: err.message || "Unknown error",
        simulated: true,
      },
    ];
  }
}
