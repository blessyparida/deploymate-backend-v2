import fs from "fs";
import path from "path";
import { Octokit } from "@octokit/rest";
import jwt from "jsonwebtoken";

/** -------------------------
 * üîê Auth Helper for GitHub App
 -------------------------- */
async function getAppOctokit() {
  const appId = process.env.GITHUB_APP_ID!;
  const installationId = process.env.GITHUB_INSTALLATION_ID!;
  const privateKey = fs.readFileSync(process.env.GITHUB_PRIVATE_KEY_PATH!, "utf8");

  // Create a short-lived JWT (10 min)
  const appJwt = jwt.sign(
    {
      iat: Math.floor(Date.now() / 1000) - 60,
      exp: Math.floor(Date.now() / 1000) + 600,
      iss: appId,
    },
    privateKey,
    { algorithm: "RS256" }
  );

  // Exchange JWT for installation access token
  const appOctokit = new Octokit({ auth: `Bearer ${appJwt}` });
  const { data } = await appOctokit.request(
    `POST /app/installations/${installationId}/access_tokens`
  );

  // Return Octokit authenticated as the installation
  return new Octokit({ auth: data.token });
}

/** -------------------------
 * üöÄ Main Commit & PR Function
 -------------------------- */
interface CommitPRParams {
  owner: string;
  repo: string;
  branch: string;
  repoDir: string;
  generatedFiles: Record<string, string>;
}

export async function commitAndPR({
  owner,
  repo,
  branch,
  repoDir,
  generatedFiles,
}: CommitPRParams) {
  const octokit = await getAppOctokit();
  const prResults: any[] = [];

  try {
    // 1Ô∏è‚É£ Get latest commit info
    const { data: refData } = await octokit.git.getRef({
      owner,
      repo,
      ref: `heads/${branch}`,
    });

    const latestCommitSha = refData.object.sha;
    const { data: latestCommit } = await octokit.git.getCommit({
      owner,
      repo,
      commit_sha: latestCommitSha,
    });

    const baseTreeSha = latestCommit.tree.sha;

    // 2Ô∏è‚É£ Prepare new tree items
    const treeItems = Object.entries(generatedFiles).map(([filePath, content]) => ({
      path: filePath,
      mode: "100644" as const,
      type: "blob" as const,
      content,
    }));

    // 3Ô∏è‚É£ Create new tree
    const { data: treeData } = await octokit.git.createTree({
      owner,
      repo,
      base_tree: baseTreeSha,
      tree: treeItems as any, // TS bypass for Octokit types
    });

    // 4Ô∏è‚É£ Create new commit
    const newCommitMessage = `üîß DeployMate Auto Commit: ${Object.keys(generatedFiles).join(", ")}`;
    const { data: newCommit } = await octokit.git.createCommit({
      owner,
      repo,
      message: newCommitMessage,
      tree: treeData.sha,
      parents: [latestCommitSha],
    });

    // 5Ô∏è‚É£ Create a new branch for PR
    const newBranch = `deploymate-auto-${Date.now()}`;
    await octokit.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${newBranch}`,
      sha: newCommit.sha,
    });

    // 6Ô∏è‚É£ Create Pull Request
    const { data: pr } = await octokit.pulls.create({
      owner,
      repo,
      title: " DeployMate Auto Config PR",
      head: newBranch,
      base: branch,
      body: "This PR was automatically generated by **DeployMate** to add or update deployment configuration files.",
    });

    prResults.push({
      success: true,
      prUrl: pr.html_url,
      branch: newBranch,
    });

    console.log(`‚úÖ Pull Request created: ${pr.html_url}`);
  } catch (err: any) {
    console.error("‚ùå Error creating commit/PR:", err.message);
    prResults.push({ success: false, error: err.message });
  }

  return prResults;
}
